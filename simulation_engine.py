# -*- coding: utf-8 -*-
"""simulation_engine

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10wZdhZLnax-QtE-NqzPWSG2L96IJ3Bn2
"""

# Arquivo: simulation_engine.py
import pandas as pd
import numpy as np
from datetime import timedelta

# =============================================================================
# CONSTANTES E PARÂMETROS FÍSICOS
# =============================================================================

# Constantes para Lucas do Rio Verde, MT
LATITUDE = -13.05  # Graus decimais
ALTITUDE = 380    # Metros

def _atualizar_parametros_cultura(gdu_acumulado, cfg):
    """Atualiza o estádio fenológico da cultura com base no GDU acumulado."""
    if gdu_acumulado < cfg['gdu_inicio_reprodutivo']:
        estadio = "Vegetativo"
    elif gdu_acumulado < cfg['gdu_enchimento_graos']:
        estadio = "Florescimento"
    else:
        estadio = "Enchimento de Grãos"
    return estadio

def _calcular_eto_penman_monteith(dia_clima, dia_do_ano):
    """
    Calcula a Evapotranspiração de Referência (ETo) usando a equação FAO-56 Penman-Monteith.
    Esta é uma implementação detalhada do método padrão-ouro.
    """
    # --- 1. Entrada de Dados ---
    t_max = dia_clima['Tmax']
    t_min = dia_clima['Tmin']
    rh_mean = dia_clima['RH_mean']
    u2 = dia_clima['Wind_speed'] # Velocidade do vento a 2m
    rs = dia_clima['Solar_Rad'] / 1000  # Radiação Solar de kJ/m²/dia para MJ/m²/dia

    # --- 2. Parâmetros Físicos e Geométricos ---
    t_mean = (t_max + t_min) / 2
    albedo = 0.23 # Albedo padrão para culturas agrícolas
    phi = np.deg2rad(LATITUDE) # Latitude em radianos

    # Pressão atmosférica (P) e Constante psicrométrica (gamma)
    P = 101.3 * ((293 - 0.0065 * ALTITUDE) / 293) ** 5.26
    gamma = 0.000665 * P

    # --- 3. Radiação ---
    # Radiação extraterrestre (Ra)
    dr = 1 + 0.033 * np.cos(2 * np.pi / 365 * dia_do_ano)
    delta_sol = 0.409 * np.sin(2 * np.pi / 365 * dia_do_ano - 1.39)
    ws = np.arccos(-np.tan(phi) * np.tan(delta_sol))
    Ra = (24 * 60 / np.pi) * 0.0820 * dr * (ws * np.sin(phi) * np.sin(delta_sol) + np.cos(phi) * np.cos(delta_sol) * np.sin(ws))

    # Radiação de céu claro (Rso)
    Rso = (0.75 + 2e-5 * ALTITUDE) * Ra

    # Radiação líquida (Rn)
    Rns = (1 - albedo) * rs # Radiação líquida de ondas curtas

    # Pressão de vapor
    e_tmax = 0.6108 * np.exp((17.27 * t_max) / (t_max + 237.3))
    e_tmin = 0.6108 * np.exp((17.27 * t_min) / (t_min + 237.3))
    es = (e_tmax + e_tmin) / 2 # Pressão de vapor de saturação média
    ea = (rh_mean / 100) * es # Pressão de vapor atual

    # Radiação líquida de ondas longas (Rnl)
    sigma = 4.903e-9 # Constante de Stefan-Boltzmann [MJ K-4 m-2 dia-1]
    Rnl = sigma * (((t_max + 273.16)**4 + (t_min + 273.16)**4) / 2) * (0.34 - 0.14 * np.sqrt(ea)) * (1.35 * (rs / Rso if Rso > 0 else 0) - 0.35)

    Rn = Rns - Rnl # Radiação líquida final

    # --- 4. Cálculo final do ETo ---
    delta_svp = 4098 * (0.6108 * np.exp((17.27 * t_mean) / (t_mean + 237.3))) / ((t_mean + 237.3)**2)

    termo_radiacao = (0.408 * delta_svp * Rn)
    termo_vento = (gamma * (900 / (t_mean + 273)) * u2 * (es - ea))
    denominador = (delta_svp + gamma * (1 + 0.34 * u2))

    ETo = (termo_radiacao + termo_vento) / denominador
    return max(0, ETo) # ETo não pode ser negativo

def gerar_dados_climaticos_monte_carlo(data_inicio, duracao_ciclo):
    """
    Gera um cenário climático sintético (Tmin, Tmax, Precip, Radiação, Umidade, Vento)
    usando o método de Monte Carlo com correlações entre variáveis.
    """
    # Parâmetros estatísticos mensais extraídos de Dados_Climaticos_Preenchidos.csv
    params_clima = {
        # Tmin(C), Tmax(C), Precip(mm), Solar_Rad(kJ/m²), RH(%), Wind(m/s)
        1: {'tmin_avg': 22.6, 'tmin_std': 0.8, 'tmax_avg': 31.4, 'tmax_std': 1.4, 'rain_prob': 0.75, 'rain_gamma_shape': 0.8, 'rain_gamma_scale': 20, 'rad_avg': 16500, 'rad_std': 3500, 'rh_avg': 82, 'rh_std': 6, 'wind_avg': 1.2, 'wind_std': 0.4},
        2: {'tmin_avg': 22.6, 'tmin_std': 0.7, 'tmax_avg': 31.5, 'tmax_std': 1.5, 'rain_prob': 0.70, 'rain_gamma_shape': 0.8, 'rain_gamma_scale': 19, 'rad_avg': 17000, 'rad_std': 4000, 'rh_avg': 83, 'rh_std': 6, 'wind_avg': 1.1, 'wind_std': 0.4},
        3: {'tmin_avg': 22.6, 'tmin_std': 0.8, 'tmax_avg': 31.8, 'tmax_std': 1.4, 'rain_prob': 0.65, 'rain_gamma_shape': 0.7, 'rain_gamma_scale': 18, 'rad_avg': 17200, 'rad_std': 3800, 'rh_avg': 82, 'rh_std': 7, 'wind_avg': 1.1, 'wind_std': 0.4},
        4: {'tmin_avg': 22.2, 'tmin_std': 1.2, 'tmax_avg': 32.1, 'tmax_std': 1.3, 'rain_prob': 0.40, 'rain_gamma_shape': 0.6, 'rain_gamma_scale': 15, 'rad_avg': 18000, 'rad_std': 3500, 'rh_avg': 78, 'rh_std': 8, 'wind_avg': 1.2, 'wind_std': 0.5},
        5: {'tmin_avg': 20.4, 'tmin_std': 1.8, 'tmax_avg': 31.8, 'tmax_std': 1.5, 'rain_prob': 0.15, 'rain_gamma_shape': 0.5, 'rain_gamma_scale': 10, 'rad_avg': 17500, 'rad_std': 3000, 'rh_avg': 72, 'rh_std': 9, 'wind_avg': 1.4, 'wind_std': 0.5},
        6: {'tmin_avg': 18.5, 'tmin_std': 2.2, 'tmax_avg': 31.9, 'tmax_std': 1.8, 'rain_prob': 0.05, 'rain_gamma_shape': 0.4, 'rain_gamma_scale': 8, 'rad_avg': 17800, 'rad_std': 2500, 'rh_avg': 66, 'rh_std': 10, 'wind_avg': 1.6, 'wind_std': 0.6},
        7: {'tmin_avg': 17.8, 'tmin_std': 2.4, 'tmax_avg': 32.6, 'tmax_std': 2.0, 'rain_prob': 0.05, 'rain_gamma_shape': 0.4, 'rain_gamma_scale': 8, 'rad_avg': 18500, 'rad_std': 2800, 'rh_avg': 61, 'rh_std': 11, 'wind_avg': 1.7, 'wind_std': 0.6},
        8: {'tmin_avg': 19.3, 'tmin_std': 2.6, 'tmax_avg': 34.5, 'tmax_std': 1.9, 'rain_prob': 0.10, 'rain_gamma_shape': 0.5, 'rain_gamma_scale': 10, 'rad_avg': 19500, 'rad_std': 3200, 'rh_avg': 55, 'rh_std': 12, 'wind_avg': 1.8, 'wind_std': 0.6},
        9: {'tmin_avg': 21.8, 'tmin_std': 2.0, 'tmax_avg': 35.6, 'tmax_std': 1.8, 'rain_prob': 0.25, 'rain_gamma_shape': 0.6, 'rain_gamma_scale': 12, 'rad_avg': 20500, 'rad_std': 3500, 'rh_avg': 58, 'rh_std': 10, 'wind_avg': 1.9, 'wind_std': 0.6},
        10: {'tmin_avg': 22.7, 'tmin_std': 1.3, 'tmax_avg': 34.7, 'tmax_std': 1.9, 'rain_prob': 0.55, 'rain_gamma_shape': 0.7, 'rain_gamma_scale': 16, 'rad_avg': 19000, 'rad_std': 4000, 'rh_avg': 70, 'rh_std': 9, 'wind_avg': 1.6, 'wind_std': 0.5},
        11: {'tmin_avg': 22.8, 'tmin_std': 1.0, 'tmax_avg': 32.8, 'tmax_std': 1.8, 'rain_prob': 0.65, 'rain_gamma_shape': 0.8, 'rain_gamma_scale': 18, 'rad_avg': 18000, 'rad_std': 4200, 'rh_avg': 76, 'rh_std': 8, 'wind_avg': 1.4, 'wind_std': 0.5},
        12: {'tmin_avg': 22.7, 'tmin_std': 0.9, 'tmax_avg': 31.8, 'tmax_std': 1.6, 'rain_prob': 0.70, 'rain_gamma_shape': 0.8, 'rain_gamma_scale': 19, 'rad_avg': 17000, 'rad_std': 3800, 'rh_avg': 80, 'rh_std': 7, 'wind_avg': 1.3, 'wind_std': 0.4}
    }

    datas = pd.date_range(start=data_inicio, periods=duracao_ciclo, freq='D')
    clima_gerado = []

    for dia in datas:
        mes = dia.month
        params = params_clima[mes]

        # Simulação de Precipitação
        choveu = np.random.rand() < params['rain_prob']
        precipitacao = np.random.gamma(params['rain_gamma_shape'], params['rain_gamma_scale']) if choveu else 0

        # Simulação de Temperatura com correlação à chuva (dias chuvosos são mais frios)
        tmin_mod = params['tmin_avg'] - 1.5 if choveu else params['tmin_avg']
        tmax_mod = params['tmax_avg'] - 2.5 if choveu else params['tmax_avg']
        tmin = np.random.normal(tmin_mod, params['tmin_std'])
        tmax = np.random.normal(tmax_mod, params['tmax_std'])
        if tmin > tmax: tmin, tmax = tmax, tmin # Garante consistência

        # Simulação de Radiação Solar com correlação à chuva
        rad_mod = params['rad_avg'] * np.random.uniform(0.4, 0.7) if choveu else params['rad_avg'] # Redução drástica se chove
        solar_rad = np.random.normal(rad_mod, params['rad_std'])
        solar_rad = max(5000, solar_rad) # Valor mínimo para evitar radiação negativa/irreal

        # Simulação da Umidade Relativa com correlação à chuva
        rh_mod = params['rh_avg'] + 10 if choveu else params['rh_avg'] # Aumenta umidade se chove
        rh_mean = np.random.normal(rh_mod, params['rh_std'])
        rh_mean = min(max(40, rh_mean), 99) # Limita a umidade a um range realista

        # Simulação da Velocidade do Vento
        wind_speed = np.random.normal(params['wind_avg'], params['wind_std'])
        wind_speed = max(0.5, wind_speed) # Garante uma velocidade mínima

        clima_gerado.append({
            'Tmin': tmin, 'Tmax': tmax, 'Precipitacao': precipitacao,
            'Solar_Rad': solar_rad, 'RH_mean': rh_mean, 'Wind_speed': wind_speed
        })

    return pd.DataFrame(clima_gerado, index=datas)

def _simular_ciclo_completo(dados_clima_cenario, cfg):
    """Executa a simulação de um ciclo completo para um único cenário climático."""
    gdu_acumulado = 0.0
    estresse_por_estadio = {"Vegetativo": 0, "Florescimento": 0, "Enchimento de Grãos": 0}
    capacidade_max_solo, ponto_murcha = 150.0, 50.0
    armazenamento_agua = capacidade_max_solo # Inicia com solo em capacidade de campo

    for i in range(len(dados_clima_cenario)):
        dia_atual = dados_clima_cenario.iloc[i]

        # Acessa o índice do DataFrame diretamente para obter o dia do ano.
        dia_do_ano = dados_clima_cenario.index[i].dayofyear

        t_max, t_min, precipitacao = dia_atual.Tmax, dia_atual.Tmin, dia_atual.Precipitacao
        gdu_diario = max(0, ((t_max + t_min) / 2) - cfg['T_BASE'])
        estadio_atual = _atualizar_parametros_cultura(gdu_acumulado, cfg)

        # Cálculo da Evapotranspiração pelo método Penman-Monteith
        eto_diario = _calcular_eto_penman_monteith(dia_atual, dia_do_ano)

        # Coeficiente da cultura (Kc)
        kc = 1.15 if estadio_atual in ["Florescimento", "Enchimento de Grãos"] else 0.5
        etc_diario = eto_diario * kc # Evapotranspiração da Cultura

        # Balanço hídrico do solo
        armazenamento_agua = max(ponto_murcha, min(capacidade_max_solo, armazenamento_agua + precipitacao - etc_diario))

        fator_estresse = 1.0
        # Limiar de estresse hídrico em 40% da água disponível para a planta (ADP)
        if armazenamento_agua < (ponto_murcha + (capacidade_max_solo - ponto_murcha) * 0.4):
            fator_estresse = 0.5
            if estadio_atual in estresse_por_estadio:
                estresse_por_estadio[estadio_atual] += 1

        gdu_ajustado_diario = gdu_diario * fator_estresse
        gdu_acumulado += gdu_ajustado_diario

    return pd.Series({
        'gdu_final': gdu_acumulado,
        'dias_estresse_total': sum(estresse_por_estadio.values()),
        'estresse_vegetativo': estresse_por_estadio["Vegetativo"],
        'estresse_florescimento': estresse_por_estadio["Florescimento"],
        'estresse_ench_graos': estresse_por_estadio["Enchimento de Grãos"]
    })

def executar_analise_probabilistica(datas_de_plantio, duracao_ciclo, params_cultura, t_base, num_simulacoes=200):
    """
    Executa a análise completa usando N simulações de Monte Carlo para cada data de plantio.
    """
    todos_os_resultados = []

    for data_plantio in datas_de_plantio:
        for i in range(num_simulacoes):
            dados_cenario = gerar_dados_climaticos_monte_carlo(data_plantio, duracao_ciclo)

            if len(dados_cenario) >= duracao_ciclo:
                cfg = {**params_cultura, 'T_BASE': t_base}
                resultado_simulacao = _simular_ciclo_completo(dados_cenario, cfg)
                resultado_simulacao['data_plantio'] = data_plantio
                resultado_simulacao['simulacao_n'] = i + 1
                todos_os_resultados.append(resultado_simulacao)

    if not todos_os_resultados:
        return pd.DataFrame()

    return pd.DataFrame(todos_os_resultados)